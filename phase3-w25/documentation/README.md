
# Semantic Anaylzer

This semantic analyzer uses the abstract syntax tree created by the parser. The semantic analyzer semantically checks if the code is correct according to the rules of the language. Checks if varaibles are declarted, if types of varaible are compatiable and if varaible are used within their correct scope.

# Parser

This parser creates an abstract syntax tree, from a stream of tokens generated by the lexical analyzer. The parser supports binary and comparison operators. It also supports parentheses and different statement types such as if, while, repeat-until, print, and block. Some special features are also supported, such as block scoping and a factorial function. There is also built-in error handling.

## File Structure

- **parser.h**  
  Defines AST node structure and its types, also defines error types.

- **parser.c**  
  Implements the parser using the stream of tokens from lexer.c.

- **lexer.h**  
  Declares the functions for token generation and error reporting in the lexical analyzer.

- **lexer.c**  
  Implements the lexical analyzer, which tokenizes the input and identifies keywords, operators, and other syntax elements.

- **semantic.h**  
  Declares the symbol table structure and functions for semantic analysis.

- **semantic.c**  
  Implements semantic analysis, including variable declaration checks, type validation, and scope handling.

## Functions Overview

### Lexer Functions
- **`get_next_token`**  
  Reads the input and generates the next token, updating line and column numbers for error reporting.

- **`print_token`**  
  Prints the details of a token for debugging purposes.

- **`print_error`**  
  Reports lexical errors, such as invalid characters or consecutive operators.

### Parser Functions
- **`parser_init`**  
  Initializes the parser with the input source code.

- **`parse`**  
  Parses the input and constructs the abstract syntax tree (AST).

- **`print_ast`**  
  Prints the AST in a readable format for debugging.

- **`free_ast`**  
  Frees the memory allocated for the AST.

### Semantic Analysis Functions
- **`analyze_semantics`**  
  Performs semantic checks on the AST, such as variable declarations and type correctness.

- **`check_declaration`**  
  Validates variable declarations and adds them to the symbol table.

- **`check_assignment`**  
  Ensures variables are declared and initialized before assignment.

- **`check_expression`**  
  Validates expressions for type correctness and undeclared variables.

- **`check_block`**  
  Handles scope management for blocks of code.

- **`check_condition`**  
  Validates conditions in control statements like if and while.

## Semantic Checking Rules

- **Declaration & Usage:**  
  Every variable must be declared before use. The symbol table records each variableâ€™s name, type, scope, and initialization status.

- **Redeclaration & Shadowing:**  
  Redeclaring a variable in the same scope is an error; inner scopes may redeclare (shadow) outer variables.

- **Initialization & Type Checking:**  
  Variables must be initialized before use, and all expressions must use type-compatible operands.

- **Scope Management:**  
  Each block (e.g., in if, while, or explicit blocks) creates a new scope. Functions like `enter_scope()` and `exit_scope()` ensure that variables are only accessible within their valid scope.

- **Control Structures:**  
  Conditions in control statements are validated for semantic correctness.

- **Error Reporting:**  
  Descriptive errors (including variable names and line numbers) are generated for any semantic violations.